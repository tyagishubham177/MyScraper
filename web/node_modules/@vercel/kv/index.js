const valueStore = new Map();
const hashStore = new Map();

function isExpired(entry) {
  if (!entry) return true;
  if (!entry.expiresAt) return false;
  return Date.now() > entry.expiresAt;
}

export const kv = {
  async get(key) {
    const entry = valueStore.get(key);
    if (!entry || isExpired(entry)) {
      if (entry && isExpired(entry)) {
        valueStore.delete(key);
      }
      return null;
    }
    return entry.value;
  },
  async set(key, value, options = {}) {
    const expiresAt = options.ex ? Date.now() + options.ex * 1000 : null;
    valueStore.set(key, { value, expiresAt });
  },
  async del(key) {
    valueStore.delete(key);
    hashStore.delete(key);
  },
  async hgetall(key) {
    const hash = hashStore.get(key);
    if (!hash || hash.size === 0) return null;
    const result = {};
    for (const [field, value] of hash.entries()) {
      result[field] = value;
    }
    return result;
  },
  async hset(key, values) {
    let hash = hashStore.get(key);
    if (!hash) {
      hash = new Map();
      hashStore.set(key, hash);
    }
    for (const [field, value] of Object.entries(values || {})) {
      hash.set(field, value);
    }
  },
  async hget(key, field) {
    const hash = hashStore.get(key);
    if (!hash) return null;
    return hash.get(field) ?? null;
  },
  async hdel(key, ...fields) {
    const hash = hashStore.get(key);
    if (!hash) return 0;
    let removed = 0;
    for (const field of fields) {
      if (hash.delete(field)) {
        removed += 1;
      }
    }
    if (hash.size === 0) {
      hashStore.delete(key);
    }
    return removed;
  }
};
